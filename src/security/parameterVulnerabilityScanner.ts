import { ParameterTester, Parameter, ParameterVulnerability, PayloadGenerationOptions } from './parameterTester';
import { AIPayloadGenerator, PayloadContext } from './aiPayloadGenerator';
import { logger } from '../utils/logger';

export interface EndpointParameter {
  endpoint: string;
  method: string;
  parameters: Parameter[];
  authentication?: {
    required: boolean;
    type: string;
    credentials?: any;
  };
}

export interface ParameterScanOptions extends PayloadGenerationOptions {
  concurrency?: number;
  timeoutPerParameter?: number;
  skipParameters?: string[];
  targetSeverity?: 'ALL' | 'CRITICAL' | 'HIGH' | 'MEDIUM';
  enableSmartTesting?: boolean;
  adaptiveTesting?: boolean;
}

export interface ParameterScanResult {
  endpoint: string;
  method: string;
  scanStartTime: string;
  scanEndTime: string;
  totalParametersTested: number;
  vulnerabilitiesFound: number;
  vulnerabilities: ParameterVulnerability[];
  scanSummary: {
    byParameter: Record<string, number>;
    bySeverity: Record<string, number>;
    byTechnique: Record<string, number>;
    averageTestTime: number;
    payloadsGenerated: number;
    aiEnhancedPayloads: number;
  };
  recommendations: string[];
  riskScore: number;
}

export interface ComprehensiveParameterReport {
  scanId: string;
  targetCount: number;
  totalVulnerabilities: number;
  totalParametersTested: number;
  scanDuration: number;
  overallRiskScore: number;
  results: ParameterScanResult[];
  executiveSummary: string;
  topVulnerabilities: ParameterVulnerability[];
  remediationPriority: Array<{
    vulnerability: ParameterVulnerability;
    priority: 'URGENT' | 'HIGH' | 'MEDIUM' | 'LOW';
    estimatedEffort: string;
  }>;
}

export class ParameterVulnerabilityScanner {
  private parameterTester: ParameterTester;
  private aiPayloadGenerator: AIPayloadGenerator;
  private scanId: string;
  private options: ParameterScanOptions;

  constructor(options: Partial<ParameterScanOptions> = {}) {
    // Set defaults
    this.options = {
      concurrency: 3,
      timeoutPerParameter: 30000,
      skipParameters: [],
      targetSeverity: 'ALL',
      enableSmartTesting: true,
      adaptiveTesting: true,
      useAI: true,
      maxPayloads: 50,
      includeAdvanced: true,
      ...options
    } as ParameterScanOptions;
    
    this.parameterTester = new ParameterTester(this.options);
    this.aiPayloadGenerator = new AIPayloadGenerator();
    this.scanId = `param_scan_${Date.now()}`;
  }

  async scanEndpoint(
    endpointParam: EndpointParameter,
    progressCallback?: (progress: string) => void
  ): Promise<ParameterScanResult> {
    
    const scanStartTime = new Date().toISOString();
    logger.info(`Starting parameter vulnerability scan for: ${endpointParam.method} ${endpointParam.endpoint}`);

    if (progressCallback) {
      progressCallback(`ðŸ” Starting parameter scan for ${endpointParam.endpoint}...`);
    }

    try {
      const vulnerabilities: ParameterVulnerability[] = [];
      let totalPayloadsGenerated = 0;
      let aiEnhancedPayloads = 0;
      const parameterTestTimes: number[] = [];

      // Filter parameters to test
      const parametersToTest = endpointParam.parameters.filter(param => 
        !this.options.skipParameters?.includes(param.name)
      );

      if (progressCallback) {
        progressCallback(`ðŸ“‹ Testing ${parametersToTest.length} parameters...`);
      }

      // Test each parameter
      for (let i = 0; i < parametersToTest.length; i++) {
        const parameter = parametersToTest[i];
        const paramStartTime = Date.now();

        if (progressCallback) {
          progressCallback(`ðŸ§ª Testing parameter ${i + 1}/${parametersToTest.length}: ${parameter.name}`);
        }

        try {
          // Create payload context for AI enhancement
          const context: PayloadContext = {
            parameterName: parameter.name,
            parameterType: parameter.type,
            endpoint: endpointParam.endpoint,
            method: endpointParam.method,
            applicationContext: await this.detectApplicationContext(endpointParam.endpoint),
            previousFindings: this.getPreviousFindings(parameter.name)
          };

          // Generate AI-enhanced payloads if enabled
          let enhancedPayloads: any[] = [];
          if (this.options.useAI) {
            const aiPayloads = await this.aiPayloadGenerator.generatePayloads(parameter, context);
            enhancedPayloads = aiPayloads;
            totalPayloadsGenerated += aiPayloads.length;
            aiEnhancedPayloads += aiPayloads.filter(p => p.source === 'ai_generated' || p.source === 'ml_enhanced').length;
          }

          // Test parameter with enhanced payloads
          const paramVulns = await this.parameterTester.testParameter(
            endpointParam.endpoint,
            endpointParam.method,
            parameter
          );

          vulnerabilities.push(...paramVulns);
          
          const testTime = Date.now() - paramStartTime;
          parameterTestTimes.push(testTime);

          if (progressCallback && paramVulns.length > 0) {
            progressCallback(`ðŸš¨ Found ${paramVulns.length} vulnerabilities in ${parameter.name}`);
          }

          // Adaptive testing: adjust strategy based on findings
          if (this.options.adaptiveTesting && paramVulns.length > 0) {
            await this.adaptTestingStrategy(paramVulns);
          }

        } catch (error: any) {
          logger.warn(`Parameter testing failed for ${parameter.name}: ${error.message}`);
        }
      }

      const scanEndTime = new Date().toISOString();
      
      if (progressCallback) {
        progressCallback(`âœ… Parameter scan completed. Found ${vulnerabilities.length} vulnerabilities.`);
      }

      // Generate scan result
      const result = this.generateScanResult(
        endpointParam,
        scanStartTime,
        scanEndTime,
        vulnerabilities,
        parameterTestTimes,
        totalPayloadsGenerated,
        aiEnhancedPayloads
      );

      return result;

    } catch (error: any) {
      logger.error(`Parameter vulnerability scan failed: ${error.message}`);
      throw error;
    }
  }

  async scanMultipleEndpoints(
    endpoints: EndpointParameter[],
    progressCallback?: (progress: string) => void
  ): Promise<ComprehensiveParameterReport> {
    
    const overallStartTime = Date.now();
    logger.info(`Starting comprehensive parameter scan for ${endpoints.length} endpoints`);

    if (progressCallback) {
      progressCallback(`ðŸš€ Starting comprehensive parameter scan for ${endpoints.length} endpoints...`);
    }

    try {
      const results: ParameterScanResult[] = [];
      
      // Process endpoints with concurrency control
      for (let i = 0; i < endpoints.length; i += (this.options.concurrency || 3)) {
        const batch = endpoints.slice(i, i + (this.options.concurrency || 3));
        
        if (progressCallback) {
          progressCallback(`ðŸ”„ Processing endpoint batch ${Math.floor(i / (this.options.concurrency || 3)) + 1}...`);
        }

        const batchPromises = batch.map(endpoint => 
          this.scanEndpoint(endpoint, progressCallback)
        );

        const batchResults = await Promise.allSettled(batchPromises);
        
        batchResults.forEach((result, index) => {
          if (result.status === 'fulfilled') {
            results.push(result.value);
          } else {
            logger.error(`Endpoint scan failed for ${batch[index].endpoint}: ${result.reason}`);
          }
        });
      }

      const scanDuration = Date.now() - overallStartTime;

      if (progressCallback) {
        progressCallback(`ðŸ“Š Generating comprehensive report...`);
      }

      // Generate comprehensive report
      const report = this.generateComprehensiveReport(results, scanDuration);

      if (progressCallback) {
        progressCallback(`ðŸŽ‰ Comprehensive parameter scan completed!`);
      }

      return report;

    } catch (error: any) {
      logger.error(`Comprehensive parameter scan failed: ${error.message}`);
      throw error;
    }
  }

  private async detectApplicationContext(endpoint: string): Promise<any> {
    // Simple application context detection
    // In a real implementation, this would be more sophisticated
    const context: any = {};

    try {
      // Framework detection based on endpoint patterns
      if (endpoint.includes('/api/v')) {
        context.framework = 'express'; // Common REST API pattern
      } else if (endpoint.includes('/graphql')) {
        context.framework = 'graphql';
      } else if (endpoint.includes('.php')) {
        context.framework = 'php';
      }

      // Database detection (simplified)
      if (endpoint.includes('mongo') || endpoint.includes('nosql')) {
        context.database = 'mongodb';
      } else if (endpoint.includes('postgres') || endpoint.includes('pg')) {
        context.database = 'postgresql';
      } else {
        context.database = 'mysql'; // Default assumption
      }

      return context;
    } catch (error) {
      return {};
    }
  }

  private getPreviousFindings(parameterName: string): Array<{ type: string; parameter: string; success: boolean }> {
    // In a real implementation, this would fetch from a database or cache
    // Simulated previous findings for AI enhancement
    return [
      { type: 'sql_injection', parameter: 'id', success: true },
      { type: 'xss', parameter: 'search', success: true },
      { type: 'command_injection', parameter: 'cmd', success: false }
    ];
  }

  private async adaptTestingStrategy(vulnerabilities: ParameterVulnerability[]): Promise<void> {
    // Adaptive testing strategy based on discovered vulnerabilities
    
    const vulnTypes = vulnerabilities.map(v => v.vulnerability.type);
    
    if (vulnTypes.includes('sql_injection')) {
      // If SQL injection found, increase focus on database-related tests
      this.options.maxPayloads = Math.min((this.options.maxPayloads || 50) + 20, 100);
      logger.info('SQL injection detected - adapting strategy to focus on database attacks');
    }

    if (vulnTypes.includes('xss')) {
      // If XSS found, focus on client-side injection tests
      this.options.includeAdvanced = true;
      logger.info('XSS detected - enabling advanced client-side injection tests');
    }

    // Adjust timeout based on response patterns
    const hasTimingVulns = vulnerabilities.some(v => v.evidence.responseTime > 3000);
    if (hasTimingVulns) {
      this.options.timeoutPerParameter = Math.max((this.options.timeoutPerParameter || 30000) + 10000, 60000);
      logger.info('Timing anomalies detected - increasing timeout for comprehensive testing');
    }
  }

  private generateScanResult(
    endpointParam: EndpointParameter,
    scanStartTime: string,
    scanEndTime: string,
    vulnerabilities: ParameterVulnerability[],
    testTimes: number[],
    payloadsGenerated: number,
    aiEnhancedPayloads: number
  ): ParameterScanResult {

    // Group vulnerabilities by parameter
    const byParameter: Record<string, number> = {};
    vulnerabilities.forEach(vuln => {
      byParameter[vuln.parameter.name] = (byParameter[vuln.parameter.name] || 0) + 1;
    });

    // Group by severity
    const bySeverity: Record<string, number> = {};
    vulnerabilities.forEach(vuln => {
      bySeverity[vuln.vulnerability.severity] = (bySeverity[vuln.vulnerability.severity] || 0) + 1;
    });

    // Group by technique
    const byTechnique: Record<string, number> = {};
    vulnerabilities.forEach(vuln => {
      byTechnique[vuln.vulnerability.type] = (byTechnique[vuln.vulnerability.type] || 0) + 1;
    });

    // Calculate risk score
    const riskScore = this.calculateRiskScore(vulnerabilities);

    // Generate recommendations
    const recommendations = this.generateRecommendations(vulnerabilities);

    return {
      endpoint: endpointParam.endpoint,
      method: endpointParam.method,
      scanStartTime,
      scanEndTime,
      totalParametersTested: endpointParam.parameters.length,
      vulnerabilitiesFound: vulnerabilities.length,
      vulnerabilities,
      scanSummary: {
        byParameter,
        bySeverity,
        byTechnique,
        averageTestTime: testTimes.reduce((a, b) => a + b, 0) / testTimes.length || 0,
        payloadsGenerated,
        aiEnhancedPayloads
      },
      recommendations,
      riskScore
    };
  }

  private generateComprehensiveReport(
    results: ParameterScanResult[],
    scanDuration: number
  ): ComprehensiveParameterReport {

    const allVulnerabilities = results.flatMap(r => r.vulnerabilities);
    const totalParametersTested = results.reduce((sum, r) => sum + r.totalParametersTested, 0);
    
    // Calculate overall risk score
    const overallRiskScore = this.calculateOverallRiskScore(results);

    // Get top vulnerabilities
    const topVulnerabilities = this.getTopVulnerabilities(allVulnerabilities);

    // Generate remediation priorities
    const remediationPriority = this.generateRemediationPriorities(allVulnerabilities);

    // Generate executive summary
    const executiveSummary = this.generateExecutiveSummary(results, allVulnerabilities);

    return {
      scanId: this.scanId,
      targetCount: results.length,
      totalVulnerabilities: allVulnerabilities.length,
      totalParametersTested,
      scanDuration,
      overallRiskScore,
      results,
      executiveSummary,
      topVulnerabilities,
      remediationPriority
    };
  }

  private calculateRiskScore(vulnerabilities: ParameterVulnerability[]): number {
    if (vulnerabilities.length === 0) return 0;

    const severityWeights = { CRITICAL: 10, HIGH: 7, MEDIUM: 4, LOW: 1 };
    const totalWeight = vulnerabilities.reduce((sum, vuln) => {
      return sum + severityWeights[vuln.vulnerability.severity];
    }, 0);

    // Normalize to 0-100 scale
    const maxPossibleScore = vulnerabilities.length * 10;
    return Math.min(Math.round((totalWeight / maxPossibleScore) * 100), 100);
  }

  private calculateOverallRiskScore(results: ParameterScanResult[]): number {
    if (results.length === 0) return 0;

    const totalScore = results.reduce((sum, result) => sum + result.riskScore, 0);
    return Math.round(totalScore / results.length);
  }

  private generateRecommendations(vulnerabilities: ParameterVulnerability[]): string[] {
    const recommendations: string[] = [];
    const vulnTypes = [...new Set(vulnerabilities.map(v => v.vulnerability.type))];

    if (vulnTypes.includes('sql_injection')) {
      recommendations.push('ðŸ›¡ï¸ Implement parameterized queries and input validation for all database interactions');
    }

    if (vulnTypes.includes('xss')) {
      recommendations.push('ðŸ”’ Implement output encoding and Content Security Policy (CSP) headers');
    }

    if (vulnTypes.includes('command_injection')) {
      recommendations.push('âš ï¸ Avoid system command execution; use safe APIs and comprehensive input validation');
    }

    if (vulnTypes.includes('nosql_injection')) {
      recommendations.push('ðŸ” Implement strict schema validation and query sanitization for NoSQL databases');
    }

    if (recommendations.length === 0) {
      recommendations.push('âœ… Continue monitoring and implement additional security hardening measures');
    }

    return recommendations;
  }

  private getTopVulnerabilities(vulnerabilities: ParameterVulnerability[]): ParameterVulnerability[] {
    const severityOrder = { CRITICAL: 4, HIGH: 3, MEDIUM: 2, LOW: 1 };
    
    return vulnerabilities
      .sort((a, b) => {
        // Sort by severity first, then by confidence
        const severityDiff = severityOrder[b.vulnerability.severity] - severityOrder[a.vulnerability.severity];
        if (severityDiff !== 0) return severityDiff;
        return b.vulnerability.confidence - a.vulnerability.confidence;
      })
      .slice(0, 10);
  }

  private generateRemediationPriorities(vulnerabilities: ParameterVulnerability[]): Array<{
    vulnerability: ParameterVulnerability;
    priority: 'URGENT' | 'HIGH' | 'MEDIUM' | 'LOW';
    estimatedEffort: string;
  }> {
    
    return vulnerabilities.map(vuln => {
      let priority: 'URGENT' | 'HIGH' | 'MEDIUM' | 'LOW';
      let estimatedEffort: string;

      switch (vuln.vulnerability.severity) {
        case 'CRITICAL':
          priority = 'URGENT';
          estimatedEffort = '1-2 days';
          break;
        case 'HIGH':
          priority = 'HIGH';
          estimatedEffort = '3-5 days';
          break;
        case 'MEDIUM':
          priority = 'MEDIUM';
          estimatedEffort = '1-2 weeks';
          break;
        default:
          priority = 'LOW';
          estimatedEffort = '2-4 weeks';
      }

      return {
        vulnerability: vuln,
        priority,
        estimatedEffort
      };
    }).slice(0, 20); // Limit to top 20 for manageable remediation planning
  }

  private generateExecutiveSummary(
    results: ParameterScanResult[],
    vulnerabilities: ParameterVulnerability[]
  ): string {
    
    const criticalCount = vulnerabilities.filter(v => v.vulnerability.severity === 'CRITICAL').length;
    const highCount = vulnerabilities.filter(v => v.vulnerability.severity === 'HIGH').length;
    const totalEndpoints = results.length;
    const averageRisk = results.reduce((sum, r) => sum + r.riskScore, 0) / results.length;

    let summary = `Parameter vulnerability assessment of ${totalEndpoints} API endpoints identified ${vulnerabilities.length} potential security issues. `;

    if (criticalCount > 0) {
      summary += `${criticalCount} CRITICAL vulnerabilities require immediate attention. `;
    }

    if (highCount > 0) {
      summary += `${highCount} HIGH severity vulnerabilities should be addressed promptly. `;
    }

    summary += `The overall risk level is ${averageRisk >= 70 ? 'HIGH' : averageRisk >= 40 ? 'MEDIUM' : 'LOW'} with an average risk score of ${Math.round(averageRisk)}. `;

    const topTypes = this.getTopVulnerabilityTypes(vulnerabilities);
    if (topTypes.length > 0) {
      summary += `Primary vulnerability types include: ${topTypes.join(', ')}.`;
    }

    return summary;
  }

  private getTopVulnerabilityTypes(vulnerabilities: ParameterVulnerability[]): string[] {
    const typeCounts: Record<string, number> = {};
    vulnerabilities.forEach(vuln => {
      typeCounts[vuln.vulnerability.type] = (typeCounts[vuln.vulnerability.type] || 0) + 1;
    });

    return Object.entries(typeCounts)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 3)
      .map(([type, count]) => `${type.replace(/_/g, ' ')} (${count})`);
  }
} 